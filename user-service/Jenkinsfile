pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    DOCKERHUB_USER = "ahmed3sjsu"
    SERVICE_NAME   = "user-service"
    IMAGE          = "docker.io/${DOCKERHUB_USER}/${SERVICE_NAME}"
    TAG            = "${env.GIT_COMMIT}".take(7)

    // GitOps uses the DEV-PROJECT monorepo
    GITOPS_REPO_SSH = "git@github.com:ahmedabdelrahman-del/DEV-PROJECT.git"
    GITOPS_BRANCH   = "main"
    // Path to kustomization.yaml inside that repo
    GITOPS_PATH     = "gitops/apps/${SERVICE_NAME}/overlays/dev/kustomization.yaml"

    DOCKERHUB_CRED  = "dockerhub-creds"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Go format (check)') {
      steps {
        dir("${SERVICE_NAME}") {
          sh 'test -z "$(gofmt -l .)"'
        }
      }
    }

    stage('Go vet') {
      steps {
        dir("${SERVICE_NAME}") {
          sh 'go vet ./...'
        }
      }
    }

    stage('Unit tests') {
      steps {
        dir("${SERVICE_NAME}") {
          sh 'go test ./...'
        }
      }
    }

    stage('Build & Push image') {
      steps {
        withCredentials([usernamePassword(credentialsId: "${DOCKERHUB_CRED}", usernameVariable: "DOCKER_USER", passwordVariable: "DOCKER_PASS")]) {
          sh '''
            set -euo pipefail
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin

            export DOCKER_BUILDKIT=1
            docker build -t "${IMAGE}:${TAG}" -t "${IMAGE}:latest" "${SERVICE_NAME}"
            docker push "${IMAGE}:${TAG}"
            docker push "${IMAGE}:latest"

            docker logout
          '''
        }
      }
    }

stage('Update GitOps (dev)') {
  steps {
    sshagent(credentials: ['gitops-repo-ssh']) {
      sh '''
        set -euo pipefail
        rm -rf gitops
        git clone -b "${GITOPS_BRANCH}" "${GITOPS_REPO_SSH}" gitops
        cd gitops

        if command -v yq >/dev/null 2>&1; then
          # Prefer YAML-aware updates when available.
          yq -i '.images[].newTag = strenv(TAG)' "${GITOPS_PATH}"
        else
          # Fallback (best-effort): replace the first newTag entry.
          sed -i.bak '0,/newTag:/s/newTag: .*/newTag: "'"${TAG}"'"/' "${GITOPS_PATH}"
        fi

        git config user.email "jenkins@local"
        git config user.name  "jenkins"

        git add "${GITOPS_PATH}"
        git commit -m "${SERVICE_NAME}: bump image tag to ${TAG}" || true
        git push origin "${GITOPS_BRANCH}"
      '''
    }
  }
}

    stage('E2E (kind smoke)') {
      steps {
        sh '''
          set -euo pipefail

          # Ensure Docker is available (kind requires it)
          if ! docker info >/dev/null 2>&1; then
            echo "Docker is not available on this agent."
            exit 1
          fi

          # Install prerequisites into a local tools dir (no sudo)
          TOOLS="$PWD/.tools"
          mkdir -p "$TOOLS"
          export PATH="$TOOLS:$PATH"

          if ! command -v kind >/dev/null 2>&1; then
            echo "Installing kind locally..."
            curl -fsSL -o "$TOOLS/kind" https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
            chmod +x "$TOOLS/kind"
          fi

          if ! command -v kubectl >/dev/null 2>&1; then
            echo "Installing kubectl locally..."
            KVER=$(curl -L -s https://dl.k8s.io/release/stable.txt)
            curl -fsSL -o "$TOOLS/kubectl" "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
            chmod +x "$TOOLS/kubectl"
          fi

          if ! command -v helm >/dev/null 2>&1; then
            echo "Installing helm locally..."
            curl -fsSL https://get.helm.sh/helm-v3.15.4-linux-amd64.tar.gz -o /tmp/helm.tgz
            tar -xzf /tmp/helm.tgz -C /tmp
            mv /tmp/linux-amd64/helm "$TOOLS/helm"
            chmod +x "$TOOLS/helm"
          fi

          # Create disposable cluster
          kind delete cluster --name dev || true
          kind create cluster --name dev --config kind-config.yaml
          kubectl wait --for=condition=Ready node --all --timeout=300s

          # Storage class
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml
          kubectl patch storageclass local-path -p '{"metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

          # Ingress
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
          kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=180s

          # Postgres
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          helm upgrade --install postgres bitnami/postgresql -f gitops/infra/postgres/values-dev.yaml
          kubectl wait --for=condition=ready pod --selector=app.kubernetes.io/name=postgresql --timeout=300s

          # Wait until DB accepts connections using a temporary client pod
          kubectl run pg-wait --rm -i --restart=Never --image=bitnami/postgresql:latest -- bash -lc '
            set -e
            for i in {1..60}; do
              pg_isready -h postgres-postgresql -p 5432 -U appuser -d appdb && exit 0
              sleep 2
            done
            exit 1
          '

          # Run DB migrations so user-service has required schema
          kubectl run psql-migrate --rm -i --restart=Never --image=bitnami/postgresql:latest -- \
            psql "postgresql://appuser:apppass@postgres-postgresql:5432/appdb?sslmode=disable" \
            -c "$(cat user-service/migrations/001_init.sql)"

          # Build & load local images for smoke
          export DOCKER_BUILDKIT=1
          docker build -t user-service:dev ./user-service
          docker build -t auth-service:dev ./auth-service
          kind load docker-image user-service:dev --name dev
          kind load docker-image auth-service:dev --name dev

          # Deploy manifests (dev overlays point to :dev images)
          kubectl apply -k gitops/apps/user-service/overlays/dev
          kubectl apply -k gitops/apps/auth-service/overlays/dev
          kubectl apply -k gitops/apps/api-ingress/overlays/dev

          kubectl rollout status deployment/user-service --timeout=300s
          kubectl rollout status deployment/auth-service --timeout=300s

          # E2E smoke: create user then login
          create_status=$(curl -s -o /tmp/create.json -w "%{http_code}" --resolve api.local:80:127.0.0.1 -H "Content-Type: application/json" -d '{"username":"ci-user","password":"ci-pass-123"}' http://api.local/api/v1/users)
          if [ "$create_status" != "200" ]; then
            echo "Create user failed with status $create_status"
            cat /tmp/create.json || true
            exit 1
          fi

          login_status=$(curl -s -o /tmp/login.json -w "%{http_code}" --resolve api.local:80:127.0.0.1 -H "Content-Type: application/json" -d '{"username":"ci-user","password":"ci-pass-123"}' http://api.local/api/v1/login)
          if [ "$login_status" != "200" ]; then
            echo "Login failed with status $login_status"
            cat /tmp/login.json || true
            exit 1
          fi

          if ! grep -q token /tmp/login.json; then
            echo "Token not present in login response"
            cat /tmp/login.json || true
            exit 1
          fi
        '''
      }
      post {
        always {
          sh 'kind delete cluster --name dev || true'
        }
      }
    }

  }

  post {
    always {
      cleanWs()
    }
  }
}
